
#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <list>


// This is an example of using ptrace() to log syscalls called by a
// child process.

namespace {

// Flag which is set in the signal number for syscall entry/exit when
// the option PTRACE_O_TRACESYSGOOD is enabled.
const int kSysFlag = 0x80;

const char *SyscallName(int sysnum) {
  switch (sysnum) {
#define MAP(name) case __NR_##name: return #name;
    MAP(access)
    MAP(arch_prctl)
    MAP(brk)
    MAP(close)
    MAP(execve)
    MAP(exit)
    MAP(exit_group)
    MAP(fstat)
    MAP(mmap)
    MAP(mprotect)
    MAP(munmap)
    MAP(open)
    MAP(read)
    MAP(write)
    default: return "?";
  }
}

}

class MmapInfo {
 public:
  uintptr_t addr;
  size_t size;
  int prot;
};

class Ptracer {
  std::list<MmapInfo> mappings_;

 public:
  void HandleSyscall(struct user_regs_struct *regs) {
    uintptr_t sysnum = regs->orig_rax;
    uintptr_t syscall_result = regs->rax;
    // uintptr_t arg1 = regs->rdi;
    uintptr_t arg2 = regs->rsi;
    uintptr_t arg3 = regs->rdx;
    uintptr_t arg4 = regs->r10;
    uintptr_t arg5 = regs->r8;
    uintptr_t arg6 = regs->r9;
    printf("syscall=%s (%i)\n", SyscallName(sysnum), (int) sysnum);

    switch (sysnum) {
      case __NR_mmap: {
        MmapInfo map;
        map.addr = syscall_result;
        map.size = arg2;
        map.prot = arg3;
        assert(arg4 == (MAP_ANON | MAP_PRIVATE));
        assert((int) arg5 == -1);
        assert(arg6 == 0);
        mappings_.push_back(map);
        break;
      }
    }
  }
};

int main(int argc, char **argv) {
  assert(argc >= 2);

  int pid = fork();
  assert(pid >= 0);
  if (pid == 0) {
    // Start tracing of the current process by the parent process.
    int rc = ptrace(PTRACE_TRACEME);
    assert(rc == 0);

    // This will trigger a SIGTRAP signal, which the parent will catch.
    execv(argv[1], argv + 1);
    perror("exec");

    _exit(1);
  }

  // Wait for the initial SIGTRAP signal generated by the child's
  // execve() call.  Since we haven't done PTRACE_SETOPTIONS yet,
  // kSysFlag isn't set in the signal number yet.
  int status;
  int rc = waitpid(pid, &status, 0);
  assert(rc == pid);
  assert(WIFSTOPPED(status));
  assert(WSTOPSIG(status) == SIGTRAP);

  // Enable kSysFlag.
  rc = ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD);
  assert(rc == 0);

  // Allow the process to continue until the next syscall entry/exit.
  rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
  assert(rc == 0);

  // Whether the next signal will indicate a syscall entry.  If false,
  // the next signal will indicate a syscall exit.
  bool syscall_entry = true;

  Ptracer ptracer;
  for (;;) {
    int status;
    int rc = waitpid(pid, &status, 0);
    assert(rc == pid);

    if (!WIFSTOPPED(status))
      break;

    if (WSTOPSIG(status) == (SIGTRAP | kSysFlag)) {
      if (syscall_entry) {
        struct user_regs_struct regs = {};
        rc = ptrace(PTRACE_GETREGS, pid, 0, &regs);
        assert(rc == 0);
        ptracer.HandleSyscall(&regs);
      }
      syscall_entry = !syscall_entry;

      // Allow the process to continue until the next syscall entry/exit.
      rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
      assert(rc == 0);
    }
  }
  return 0;
}
