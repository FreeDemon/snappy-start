
#include <assert.h>
#include <inttypes.h>
#include <stdint.h>
#include <stdio.h>
#include <sys/mman.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <unistd.h>

#include <list>


// This is an example of using ptrace() to log syscalls called by a
// child process.

namespace {

// Flag which is set in the signal number for syscall entry/exit when
// the option PTRACE_O_TRACESYSGOOD is enabled.
const int kSysFlag = 0x80;

const char *SyscallName(int sysnum) {
  switch (sysnum) {
#define MAP(name) case __NR_##name: return #name;
    MAP(access)
    MAP(arch_prctl)
    MAP(brk)
    MAP(close)
    MAP(execve)
    MAP(exit)
    MAP(exit_group)
    MAP(fstat)
    MAP(mmap)
    MAP(mprotect)
    MAP(munmap)
    MAP(open)
    MAP(read)
    MAP(write)
    default: return "?";
  }
}

uintptr_t RoundUpPageSize(uintptr_t val) {
  uintptr_t page_size = getpagesize();
  return (val + page_size - 1) & ~(page_size - 1);
}

class MmapInfo {
 public:
  uintptr_t addr;
  size_t size;
  int prot;
};

class Ptracer {
  int pid_;
  std::list<MmapInfo> mappings_;
  FILE *info_fp_;

 public:
  Ptracer(int pid): pid_(pid) {}

  void HandleSyscall(struct user_regs_struct *regs) {
    uintptr_t sysnum = regs->orig_rax;
    uintptr_t syscall_result = regs->rax;
    // uintptr_t arg1 = regs->rdi;
    uintptr_t arg2 = regs->rsi;
    uintptr_t arg3 = regs->rdx;
    uintptr_t arg4 = regs->r10;
    uintptr_t arg5 = regs->r8;
    uintptr_t arg6 = regs->r9;
    printf("syscall=%s (%i)\n", SyscallName(sysnum), (int) sysnum);

    switch (sysnum) {
      case __NR_mmap: {
        MmapInfo map;
        map.addr = syscall_result;
        map.size = RoundUpPageSize(arg2);
        map.prot = arg3;
        assert(arg4 == (MAP_ANON | MAP_PRIVATE));
        assert((int) arg5 == -1);
        assert(arg6 == 0);
        mappings_.push_back(map);
        break;
      }
    }
  }

  void Put(uint64_t val) {
    fwrite(&val, sizeof(val), 1, info_fp_);
    printf("%" PRIx64 "\n", val);
  }

  void Dump() {
    FILE *mapfile = fopen("out_pages", "w");
    assert(mapfile);
    uintptr_t mapfile_offset = 0;

    info_fp_ = fopen("out_info", "w");
    assert(info_fp_);

    struct user_regs_struct regs;
    int rc = ptrace(PTRACE_GETREGS, pid_, 0, &regs);
    assert(rc == 0);
    Put(regs.rip);

    Put(mappings_.size());
    for (auto map : mappings_) {
      Put(map.addr);
      Put(map.size);
      Put(map.prot);
      Put(mapfile_offset);

      for (uintptr_t offset = 0; offset < map.size;
           offset += sizeof(uintptr_t)) {
        uintptr_t word = ptrace(PTRACE_PEEKDATA, pid_, map.addr + offset, 0);
        fwrite(&word, sizeof(word), 1, mapfile);
      }
      mapfile_offset += map.size;
    }
    fclose(mapfile);
    fclose(info_fp_);
  }

  void TerminateSubprocess() {
    int rc = kill(pid_, SIGKILL);
    assert(rc == 0);

    // Wait for the SIGKILL signal to take effect.
    int status;
    int pid2 = waitpid(pid_, &status, 0);
    assert(pid2 == pid_);
    assert(WIFSIGNALED(status));
    assert(WTERMSIG(status) == SIGKILL);
  }
};

}

int main(int argc, char **argv) {
  assert(argc >= 2);

  int pid = fork();
  assert(pid >= 0);
  if (pid == 0) {
    // Start tracing of the current process by the parent process.
    int rc = ptrace(PTRACE_TRACEME);
    assert(rc == 0);

    // This will trigger a SIGTRAP signal, which the parent will catch.
    execv(argv[1], argv + 1);
    perror("exec");

    _exit(1);
  }

  // Wait for the initial SIGTRAP signal generated by the child's
  // execve() call.  Since we haven't done PTRACE_SETOPTIONS yet,
  // kSysFlag isn't set in the signal number yet.
  int status;
  int pid2 = waitpid(pid, &status, 0);
  assert(pid2 == pid);
  assert(WIFSTOPPED(status));
  assert(WSTOPSIG(status) == SIGTRAP);

  // Enable kSysFlag.
  int rc = ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD);
  assert(rc == 0);

  // Allow the process to continue until the next syscall entry/exit.
  rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
  assert(rc == 0);

  // Whether the next signal will indicate a syscall entry.  If false,
  // the next signal will indicate a syscall exit.
  bool syscall_entry = true;

  Ptracer ptracer(pid);
  for (;;) {
    int status;
    int rc = waitpid(pid, &status, 0);
    assert(rc == pid);

    assert(WIFSTOPPED(status));

    if (WSTOPSIG(status) == (SIGTRAP | kSysFlag)) {
      if (!syscall_entry) {
        struct user_regs_struct regs;
        rc = ptrace(PTRACE_GETREGS, pid, 0, &regs);
        assert(rc == 0);
        ptracer.HandleSyscall(&regs);
      }
      syscall_entry = !syscall_entry;

      // Allow the process to continue until the next syscall entry/exit.
      rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
      assert(rc == 0);
    } else if (WSTOPSIG(status) == SIGUSR1) {
      printf("usr1\n");
      ptracer.Dump();
      ptracer.TerminateSubprocess();
      break;
    }
  }
  return 0;
}
