
#include <assert.h>
#include <stdio.h>
#include <sys/ptrace.h>
#include <sys/user.h>
#include <sys/wait.h>
#include <sys/syscall.h>
#include <unistd.h>


// This is an example of using ptrace() to log syscalls called by a
// child process.

namespace {

// Flag which is set in the signal number for syscall entry/exit when
// the option PTRACE_O_TRACESYSGOOD is enabled.
const int kSysFlag = 0x80;

const char *syscall_name(int sysnum) {
  switch (sysnum) {
#define MAP(name) case __NR_##name: return #name;
    MAP(access)
    MAP(arch_prctl)
    MAP(brk)
    MAP(close)
    MAP(execve)
    MAP(exit)
    MAP(exit_group)
    MAP(fstat)
    MAP(mmap)
    MAP(mprotect)
    MAP(munmap)
    MAP(open)
    MAP(read)
    MAP(write)
    default: return "?";
  }
}

}

int main(int argc, char **argv) {
  assert(argc >= 2);

  int pid = fork();
  assert(pid >= 0);
  if (pid == 0) {
    // Start tracing of the current process by the parent process.
    int rc = ptrace(PTRACE_TRACEME);
    assert(rc == 0);

    // This will trigger a SIGTRAP signal, which the parent will catch.
    execv(argv[1], argv + 1);
    perror("exec");

    _exit(1);
  }

  // Wait for the initial SIGTRAP signal generated by the child's
  // execve() call.  Since we haven't done PTRACE_SETOPTIONS yet,
  // kSysFlag isn't set in the signal number yet.
  int status;
  int rc = waitpid(pid, &status, 0);
  assert(rc == pid);
  assert(WIFSTOPPED(status));
  assert(WSTOPSIG(status) == SIGTRAP);

  // Enable kSysFlag.
  rc = ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_TRACESYSGOOD);
  assert(rc == 0);

  // Allow the process to continue until the next syscall entry/exit.
  rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
  assert(rc == 0);

  // Whether the next signal will indicate a syscall entry.  If false,
  // the next signal will indicate a syscall exit.
  bool syscall_entry = true;

  for (;;) {
    int status;
    int rc = waitpid(pid, &status, 0);
    assert(rc == pid);

    if (!WIFSTOPPED(status))
      break;

    if (WSTOPSIG(status) == (SIGTRAP | kSysFlag)) {
      if (syscall_entry) {
        struct user_regs_struct regs = {};
        rc = ptrace(PTRACE_GETREGS, pid, 0, &regs);
        assert(rc == 0);
        int sysnum = regs.orig_rax;
        printf("syscall=%s (%i)\n", syscall_name(sysnum), sysnum);
      }
      syscall_entry = !syscall_entry;

      // Allow the process to continue until the next syscall entry/exit.
      rc = ptrace(PTRACE_SYSCALL, pid, 0, 0);
      assert(rc == 0);
    }
  }
  return 0;
}
